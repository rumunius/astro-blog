---
title: 今日LeetCode 定长滑动窗口
description: '好久不写代码了，有点手生。'
publishDate: 2025-11-14 23:58
tags:
  - 技术
  - 软件
  - 算法
  - 今日LeetCode
---
- [x] [1456. 定长子串中元音的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)
- [x] [643. 子数组最大平均数 I - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-average-subarray-i/description/)
- [x] [1343. 大小为 K 且平均值大于等于阈值的子数组数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/)
- [x] [1423. 可获得的最大点数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)

参照灵神的算法题单刷的。全是定长滑动窗口题。

# 滑动窗口板子

枚举窗口的右边界

```c
int ans,cnt;
for(int i=0;/* 终止条件 */;i++){
    //cnt处理进入窗口的数据arr[i];
    int left=i-k+1;
    if(left<0) continue; //尚未形成窗口
    //更新答案ans
    //cnt处理退出窗口的数据arr[left]
}
```

# 滑窗优化了什么

相当于把答案的计算进行了增量化处理。例如求窗口内的平均数，原始的滑窗思路滑一下就用一个for把区间内数据累加然后除以`k`，这样时间复杂度是$O(nk)$。但是这种优化的滑窗只需要处理入窗出窗带来的`cnt`变化。具体地对于平均数的问题，入窗时`cnt+=arr[i]/k`，出窗时`cnt-=arr[left]/k`。甚至可以把`k`提出来，在最后返回答案的时候再除。这样做把时间复杂度优化到了$O(n)$。

如果答案的计算不能进行增量化处理，那么滑窗的优势可能就失去了。

# 其他经验

尽量避免浮点数的代数运算，常数比较大，放最后除`k`是这种优化的一个体现。

> [!CAUTION] 
> 不要忘记int除int会取整，记得加一个强转double

关于[1423. 可获得的最大点数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)这一道题，确实第一眼没有太好的思路。表面上看是一道策略题（求策略使最优化），但实际上是一道拐了弯的滑窗。

我第一眼思路是DFS，但是因为它在滑动窗口的题单里所以没写（后来翻评论区发现写DFS的人会超时），瞄了一眼题解看到一句 **“把数组看成一个环”** 才有了思路。写了一个小函数`conv`做了一个下标的映射（对我来说，把子功能提成函数有利于思路~~，当然这是大脑工作记忆容量太小的体现~~）。